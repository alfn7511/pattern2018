# 8장, 9장, 11장 일부 정리

## 8장

- 프로미스 패턴
  - 지연 평가를 기반에 둠
  - 자연스럽게 비동기에 많이 의존할 수 밖에 없는 자바스크립트 프로그램을 효율적으로 제어하는데 도움이 된다

## 9장 (Messaging Patterns)

- 메세지의 전파를 통해 확장도 용이하고 단일 애플리케이션에서도 결합도를 낮추고 테스트를 용이하게 한다.
- 메세지는 서로 연관된 의미를 가지고 있는 데이터의 모음이라고 할 수 있다.
- 메세지는 애플리케이션이나 비지니스에서 행하는 액션과 관련이 있다. 메세지는 수신자가 액션을 실행하기 위해 필요한 모든 정보를 가지고 있다.
- 대부분의 메세징 시스템에서는 봉투(envelope)를 정의하고 있다. 이 봉투는 메세지 적합성 인증, 라우팅, 보안 등에 활용되는 메타데이터이다.
- 메세지는 봉인되어야 하고 한번 생성되면 변경사항이 있어선 안된다. 그래야 메세지를 추적하고 답신하기 쉬워진다.
- 보통 단일 프로세스에서 동작하는 메세지는 동기적으로 다루어진다. 메인 프로세스가 효과적으로 메세지를 처리할 때 까지 기다리는 식이다. 하지만 자바스크립트에서는 이를 비동기로 처리하도록 장려한다.
- 비동기 메세지를 처리할 때 순서가 보장되도록 잘 관리하는 등의 별도 처리가 필요하다.
- 커맨드와 이벤트로 이루어져 있다. 커맨드는 ‘어떻게 해야하는지’  전달한다고 하면 이벤트는 ‘무슨 일이 일어날 때’ 반응하도록 한다.
- 커맨드
  - 단순한 데이터 전달 객체이다.
  - 명령형으로 보이도록 (동사)(대상) 의 형식으로 이루어져있다. 무난한 이름을 피하고 이 커맨드가 무슨 일을 일으키는지 명확하게 표현하는 것이 중요하다.
  - 메세지 자체의 유용성을 높이려면 해당 비지니스의 의미를 잘 내포한 구성 요소를 가지고 있어야 한다. 이 분야를 어떻게 효과적으로 표현하고자 하는지는 많은 연구가 진행되고 있는데, Domain-Driven-Design(DDD)가 대표적인 예이다.
  - 커맨드는 그 특정 구성 요소에게 어떤 일을 하라고 하는지 정확하게 알려주는 것이다.
  - 특정 커맨드를 받아들이기 위한 엔드포인트는 딱 하나 존재한다. 이렇게 만듦으로서 엔드포인트가 메세지의 유효성을 검사하고 취소하더라도 애플리케이션의 다른 부분에 영향을 주지 않는다.
- 이벤트
  - 변경하거나 취소하는 것에 대한 정의가 없다. 이벤트는 단순히 무슨 일이 일어날때 알려주는 것이고, 과거를 바꿀 순 없기 때문이다.
  - 보통은 과거형으로 작성한다
  - 커맨드와는 달리 여러 컴포넌트로부터 수신 가능하다
  - 브라우저에서 일어나는 이벤트는 저자가 정의한 것과는 꽤 다른 모습을 보이고 있기는 하다. 이벤트 핸들러가 취소를 할수도 있고 다음 핸들러로 이벤트가 넘어가는걸 막을 수도 있기 때문이다.
  - 이벤트가 다형성을 띄는 경우도 있다.
- 요청-응답 패턴
  - 대부분의 경우 커맨드를 전송하는 일은 비동기 작업이기 때문에 ID별로 레코드를 검색해보는 등의 행동을 하기 쉽지 않다. 대신에 레코드를 검색하고 나서 그에 맞는 이벤트가 리턴되기를 기다려야 한다.
  - 그닥 권장되는 패턴은 아니다.
  - RabbitMQ, ZeroMQ 같은 메세지 전달 시스템이 있으니 조사해보는것이 좋다.
- 발행-구독 패턴
  - 코드 처리와 이벤트를 분리하는데 아주 유용한 방법
  - 메세지 발행자 측에서는 보내자마자 최대한 빨리 메세지 전달이 끝나도록 하는게 핵심이다. 적합한 형태를 갖춘 메세지를 만들고 그를 수신자에게 전달하기만 하면 된다.
  - 요청-응답 패턴에서 만들었던 버스를 조금 더 발전시켜 라우터 역할을 하게 만드는데, 메세징을 할 때 그 속성을 검사하고 그에 따라 다른 행동을 하게 하는 비지니스 로직이 들어가면 버스의 속도가 느려지고 디버깅하기 어려워진다.
- 펼쳤다 접기
  - CPU가 발전하면서 멀티 스레드 처리 및 동시성을 처리할 때 곤란한 경우가 많이 생기게 되었다. 메세지는 입력과 출력 자체에만 집중하게 하여 문제를 해결하는 듯 보인다.
  - 검색의 경우 여러 입력을 하나의 메세지로 묶을 수 있고, 약 1만개의 문서가 있다고 할 때 검색 부위를 4~5개로 나누어서 다섯 개의 메세지를 각각의 부위별로 검색하게 하여 나중에 결과를 합칠 수도 있다.
  - 브라우저에서는 웹 워커를 사용하여 펼치기 전략을 취할 수 있다. (여러 개의 코어에 접근할 수 있다)
  - 각각의 노드가(혹은 워커가) 처리하는 문제가 동일한 문제일 필요는 없으나, 메세지를 전달하면서 생기는 오버헤드보다 이 노드를 생성해서 처리하는 비용이 더 적게 만들어야 할 것이다.
- Dead-letter queues
  - 메세지 시나리오에서 실패하는 경우를 다루는건 쉽다. 실패를 다루는 전략의 핵심은 에러를 받아들이는 것이다.
  - 비동기 시스템에서는 에러가 일어나는대로 바로 처리될 필요가 없다. 대신 다른 곳에(에러 큐) 치워두고 실제 사용하는 사람이 나중에 확인하게 만들면 된다.
  - 에러가 일어날 때 어떤 속성에서 문제가 생겼는지 등을 기록하며 쌓아두면서 에러를 바로잡아 갈 수록 메세지 핸들러의 질은 높아진다. 적절하게 테스트가 완료될 때 까지 급하게 프로덕션 앱을 고치려고 할 필요도 없다. 더 정확한 시스템을 향한 과정은 계속되어야 하고 그 신뢰도를 유지해야 한다.
  - 전통적인 시스템이라면 웹 서비스에 문제가 생기는게 메세지 핸들러의 문제로 연결되지만, 메세지 기반의 시스템이라면 문제가 생겼던 명령은 한번 뒤로 돌아와서 재시도를 해보는 등의 변화를 가져갈 수 있다. 이런 방식의 접근은 작은 문제를 부드럽게 넘어가면서 큰 문제로 번지는 것을 막을 수 있다.
- 메세지 반복
  - 에러가 일어나는 메세지를 다루는 것도 중요하지만 그 메세지를 재처리하는 일도 중요하다. 심지어 에러가 없다 하더라도 사용자의 일반적인 사용 패턴을 반영하기 때문에 메세지를 검사하는 큐에서 들어오는 데이터를 테스트에 활용할 수도 있다.
  - 어떤 데이터가 왜 바뀌었는지 파악하는 것이 중요하다. (메세지 변경의 히스토리를 남기는 것)
  - 메세지 반복을 내부에서 처리하게 될 때 서비스 전체가 문제가 생긴다면 그 메세지를 복기하는 것 조차 불가능하다. 현실적으로 메세지 반복을 도입해야한다고 생각한다면 외부 메세지 버스를 도입하는게 답이다.
- 파이프와 필터
  - 메세지는 불변 객체로 다루어야 한다고 언급했지만, 메세지가 다시 발송되지 말아야 하거나 새로운 타입으로 내보내는 것을 하지 말라는 이야기는 아니다.
  - 각각의 잘게 쪼개진 연결체들(마이크로서비스)는 어떤 메세지를 받고 자신이 어떤 결과를 내놓아야하는지만 집중하고 있다. 자연스럽게 결합도는 떨어지고 새로운 기능을 추가하기 용이해진다.
  - 서비스는 각각의 메세지 소비자들이 파이프처럼 넘기듯이 메세지를 연결할 수 있고, 필터링 되는 것 처럼 메세지를 재생산할 수 있다.
- 메세지 버저닝
  - 시스템이 발전하면서 메세지에 담기는 정보도 변경될 수 있다. 이에 따라 효과적으로 데이터를 다룰 때 메세지를 버저닝하는 것이 유용하다.
  - 보통은 기존 메세지의 구조를 이어받아 확장하는 식으로 버저닝을 하게 된다. (타입스크립트의 인터페이스 상속을 하면 굉장히 유용하다)
- 모든 애플리케이션이 메세징을 도입한다고 잘 동작하는건 아니다. 상호 협력적이고 데이터 손실을 피하면서 기록을 열심히 남겨야 하는 환경이 적합한 후보가 된다. 대부분의 경우 일반적인 CRUD 구성으로도 충분하다.

## 11장 고급 패턴

- 의존성 주입
  - 프로젝트 규모가 커질 수록 기능을 직접 주입하는 일은 점점 어려워진다. 우리가 객체 생성 자체를 서비스로 생각할 때 문제를 해결하기 쉬워진다. 객체 생성을 중앙에서 관리하면 그 부분에서만 변경 사항을 다루는 것이다. 새 구현은 어떻게든 해당 인터페이스를 만족하고 있으니 걱정할 필요가 없어진다.
  - 그러나 자바나 C#같은데서는 타입과 인터페이스로 의존성 주입을 명확하게 지정할 수 있는 반면 자바스크립트에서는 변수명 정도에 의존할 수 밖에 없다는 문제가 있다. 이는 보통 프로덕션에서 자바스크립트 파일을 축소할 때 문제를 야기할 수도 있다.